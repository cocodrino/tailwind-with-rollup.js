'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var acorn = require('acorn');
var estreeWalker = require('estree-walker');
var postcss = _interopDefault(require('postcss'));
var postcssJs = _interopDefault(require('postcss-js'));
var tailwindcss = _interopDefault(require('tailwindcss'));
var MagicString = _interopDefault(require('magic-string'));
var fs = _interopDefault(require('fs'));
var minimatch = _interopDefault(require('minimatch'));

const formatTailwindObject = object => {
  return Object.keys(object).filter(key => key.includes(".")).map(key => {
    let newKey = key.replace("\\", "");
    return {
      [newKey]: object[key]
    };
  }).reduce((acc, current) => {
    for (const key in current) {
      if (key.includes(",")) {
        const splitKey = key.split(",");
        acc[splitKey[0]] = current[key];
        acc[splitKey[1]] = current[key];
        delete acc[key];
        return acc;
      }

      acc[key] = current[key];
    }

    return acc;
  }, {});
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

const isVariant = name => selector => {
  return selector.startsWith(`${name}:`);
};

const addSelector = name => (tailwind, state, selector) => {
  const nameWithoutVariant = selector.split(":")[1];
  return _objectSpread({}, state, {
    [`:${name}`]: _objectSpread({}, state[`:${name}`], tailwind[`.${nameWithoutVariant}`])
  });
};

const addMediaSelector = (tailwind, state, selector, config) => {
  const _selector$split = selector.split(":"),
        _selector$split2 = _slicedToArray(_selector$split, 2),
        size = _selector$split2[0],
        nameWithoutMedia = _selector$split2[1];

  const media = `@media (min-width: ${config.screens[size]})`;
  return _objectSpread({}, state, {
    [media]: _objectSpread({}, state[media], tailwind[`.${nameWithoutMedia}`])
  });
};

const processSelectors = (tailwind, config, selectors) => {
  let state = {};
  const processSelector = [{
    isRightSelector: selector => !selector.includes(":"),
    addToState: (tailwind, state, selector) => _objectSpread({}, state, tailwind[`.${selector}`])
  }, {
    isRightSelector: (selector, {
      screens
    }) => {
      return Object.keys(screens).some(screen => selector.startsWith(`${screen}:`));
    },
    addToState: addMediaSelector
  }, {
    name: "hover"
  }, {
    name: "focus"
  }, {
    name: "active"
  }, {
    name: "group-hover"
  }, {
    name: "focus-within"
  }];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = selectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const name = _step.value;

      for (var _i = 0; _i < processSelector.length; _i++) {
        const rule = processSelector[_i];
        const isRightSelector = rule.name ? isVariant(rule.name) : rule.isRightSelector;
        const addToState = rule.name ? addSelector(rule.name) : rule.addToState;

        if (isRightSelector(name, config)) {
          state = addToState(tailwind, state, name, config);
          break;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return state;
};

function ensureArray(thing) {
  if (Array.isArray(thing)) return thing;
  if (thing == undefined) return [];
  return [thing];
}

const shouldProceed = (only, file) => {
  if (file === undefined || file === null || file === "") {
    return false;
  }

  if (only.length === 0) {
    return true;
  }

  return only.some(rule => minimatch(file, rule, {
    matchBase: true
  }));
};

function tailwind(options = {}) {
  const tailwindConfigFile = options.config ? `${process.cwd()}/${options.config}` : `${process.cwd()}/tailwind.config.js`;
  const functionName = options.function ? options.function : "tailwind";
  const only = ensureArray(options.only);

  if (!fs.existsSync(tailwindConfigFile)) {
    throw Error("Cannot find Tailwind configuration file");
  }

  const tailwindConfig = require(tailwindConfigFile);

  let tailwind;
  postcss().use(tailwindcss(tailwindConfigFile)).process("@tailwind components; @tailwind utilities;", {
    from: undefined
  }).then(result => {
    tailwind = formatTailwindObject(postcssJs.objectify(result.root));
  });
  return {
    name: "transform-tailwind",

    renderChunk(code, {
      facadeModuleId
    }) {
      if (!shouldProceed(only, facadeModuleId)) {
        return;
      }

      const ast = acorn.parse(code, {
        ecmaVersion: 6,
        sourceType: "module"
      });
      const magicString = new MagicString(code);
      estreeWalker.walk(ast, {
        enter(node) {
          if (node.type !== "CallExpression" || node.callee.name !== functionName) {
            return;
          }

          const selectors = node.arguments[0].value.split(" ");
          const processedSelectors = processSelectors(tailwind, tailwindConfig, selectors);
          magicString.overwrite(node.start, node.end, JSON.stringify(processedSelectors));
        }

      });
      return magicString.toString();
    }

  };
}

exports.default = tailwind;
